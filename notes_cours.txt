Projet:
- mnist digit et y appliquer les algos qu'on va voir
- comme les autres projets mais en condensé

On va faire des K-means, PCA, AutoEncoders, (premier rendu)
SOM (Kohonen Maps), GAN (deuxième rendu)

et si tout se passe bien du VAE ou xGAN/Diffusion Models

MNIST préparer la donnéer ? trier par classe, mélanger, normaliser, standardiser ?

Machine Learning non supervisé: 
- existe-t-il des relations entre mes données ?
- existe-t-il des clusters dans mes données ?
- existe-t-il des colonnes (données) inutiles dans mon dataset ?
- peut-on visualiser de manière intelligible pour un être humain des données de grande dimmension ?
- peut-on réduire les dimensions des données pour faciliter l'apprentissage supervisé
- peut-on générer des nouvelles données artificielles ?

rélféchier pour générer de la data avec les kmeans
GAN pas fait pour compression décompression

pour chaque algo on doit avoir comment on a compresser/décompresser de la donnée
comment on a réussi à projeter les données dans un espace de dimension réduite pour faire une visulisation du dataset
générer de la nouvelle donnée 

on a le droit d'utiliser tensorflow, pytorch etc pour faire de l'autodifférentiation pour corrriger les poids
on peut utiliser adam, les optimizers etc

mais c'est nous qui devons standardiser ou calculer la matrice de covariance

#######################################################

Rappel des kmeans:
algo de lloyd: 
on initialise avec des points random, on fait la distance euclidienne avec les points, 
on trouve les plus proches, on fait la moyenne, on déplace le centre et on refait
attention de bien initialiser les points

PCA:
on a notre dataset,
on commence par le standardiser: 
- attention au type de standardisation (on centre et on réduit les données)
- est-ce qu'on standardise par colonne ou full ? 
    - si à la colonne on détruit de l'info
    - si c'est des tas de pixels on fait l'ensemble plutôt
    - variance (/ écart-type) ?
- calculer la CoMatrix
    - Bonus: GPU
- récupérer les eigen values et vector (valeurs propres / vecteurs propres)
    - attention si c'est en colonnes ou lignes qu'ils sont affichés (pour transposer ou pas)
- trier nos vecteurs propres en ordre décroissant des valeurs propres
- choisir (c'est cette étape qui change enfonction de compression, décompression, etc) K vecteurs propres 
    - ça nous donne une matrice M, pour projeter les données dans l'espace lattent, on fait juste M*Dataset -> D' (produit matriciel)
    - pour récupérer les données on fait Mt*D' -> Dataset

choisir point size petit et affichage randomisé sur les calsses de départ

#######################################################

AutoEncoders
2 modules : encoder / decoder
(z = espace latent)
(x = couche de départ / x' = reconstruction)
z = encode(x) 
x' = decode(z) 

il s'agit de prédire la même donnée que ce qui est donné en entrée
la première partie 

on utilise la MSE pour le loss
tester la RELU, la tanh, et la sigmoid en fonction de ce qu'on choisi pour normaliser

comment on utilise pour la visualisation du dataset ?
on prend tout le dataset, on le projette dans l'espace z, puis on plot ça dans l'espace 2d
pour voir où le modèle a appris à projeter ses données

pour générer de la nouvelle donnée, on va tirer des valeurs au hasard dans l'espace latent
quand il nous dit de projeter la donnée pour visualisation dans un espace latent il veut un graphique
quand il dit générer de la nouvelle donnée, soit on fait au hasard avec des nouveaux trucs, soit du sampling

pour faire l'auto encodeur c'est bien de pouvoir entrainer tout d'un coup, 
mais d'utiliser la premiere et la derniere partie séparée

genre on fait un encoder qui va jusqu'à la couche de 2 neuronnes,
on fait le décoder qui commence à 2 puis va dans l'autre sense

et l'autoencoder c'est un sequential composé de l'encoder puis du décoder

avec l'API fonctionnelle, il fait un input,
il enchaine les couches, et garde l'output decoder,

ensuite l'encoder prendre inputencoder et output encoder 

ensuite le décodeur il part de 2 puis augment, a un output decodeur 
et c'est la combien d'input decoder et output decoder